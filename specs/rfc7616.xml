<?xml version="1.0" encoding="US-ASCII"?>
<?xml-stylesheet type='text/xsl' href='rfc2629.xslt' ?>
<?rfc toc="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<!DOCTYPE rfc PUBLIC "" "lib/rfc2629.dtd" [
  <!ENTITY MAY "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MAY</bcp14>">
  <!ENTITY MUST "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST</bcp14>">
  <!ENTITY MUST-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>MUST NOT</bcp14>">
  <!ENTITY NOT-RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>NOT RECOMMENDED</bcp14>">
  <!ENTITY OPTIONAL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>OPTIONAL</bcp14>">
  <!ENTITY RECOMMENDED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>RECOMMENDED</bcp14>">
  <!ENTITY REQUIRED "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>REQUIRED</bcp14>">
  <!ENTITY SHALL "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL</bcp14>">
  <!ENTITY SHALL-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHALL NOT</bcp14>">
  <!ENTITY SHOULD "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD</bcp14>">
  <!ENTITY SHOULD-NOT "<bcp14 xmlns='http://purl.org/net/xml2rfc/ext'>SHOULD NOT</bcp14>">
]>

<rfc xmlns:x="http://purl.org/net/xml2rfc/ext" number="7616" ipr="pre5378Trust200902" category="std" consensus="yes"
     obsoletes="2617" submissionType="IETF">

<front>
  <title>HTTP Digest Access Authentication</title>
  <author initials="R." surname="Shekh-Yusef" fullname="Rifaat Shekh-Yusef" role="editor">
    <organization>Avaya</organization>
    <address>
      <postal>
        <street>250 Sidney Street</street>
        <city>Belleville</city><region>Ontario</region>
        <country>Canada</country>
      </postal>
      <phone>+1-613-967-5267</phone>
      <email>rifaat.ietf@gmail.com</email>
    </address>
  </author>
  <author initials="D." surname="Ahrens" fullname="David Ahrens">
    <organization>Independent</organization>
    <address>
      <postal>
        <street/>
        <region>California</region>
        <country>United States</country>
      </postal>
      <email>ahrensdc@gmail.com</email>
    </address>
  </author>
  <author initials="S." surname="Bremer" fullname="Sophie Bremer">
    <organization>Netzkonform</organization>
    <address>
      <postal>
        <street/>
        <country>Germany</country>
      </postal>
      <email>sophie.bremer@netzkonform.de</email>
    </address>
  </author>

  <date month="September" year="2015"/>

  <area>Security</area>
  <workgroup>HTTPAuth</workgroup>
  <keyword>HTTP</keyword>
  <keyword>authentication scheme</keyword>

  <abstract>
    <t>
      The Hypertext Transfer Protocol (HTTP) provides a simple
      challenge-response authentication mechanism that
      may be used by a server to challenge a client request and by a client
      to provide authentication information. This document defines the HTTP
      Digest Authentication scheme that can be used with the HTTP
      authentication mechanism.
    </t>
  </abstract>
</front>

<middle>
<section title="Introduction" anchor="introduction">
<t>
HTTP provides a simple challenge-response authentication mechanism that may be used by a server to challenge a client request and by a client to provide authentication information. This document defines the HTTP Digest Authentication scheme that can be used with the HTTP authentication mechanism.
</t>
<t>
This document extends but is generally backward compatible with <xref target="RFC2617"/>. See <xref target="rfc2617.changes"/> for the new capabilities introduced by this specification.
</t>
<t>
The details of the challenge-response authentication mechanism are specified in the "Hypertext Transfer Protocol (HTTP/1.1): Authentication" <xref target="RFC7235"/>.
</t>
<t>
The combination of this document with the definition of the "Basic"
authentication scheme <xref target="RFC7617"/>, "HTTP Authentication-Info and
Proxy-Authentication-Info Response Header Fields" <xref target="RFC7615"/>,
and "Hypertext Transfer Protocol (HTTP/1.1): Authentication" <xref target="RFC7235"/> obsolete <xref target="RFC2617"/>.
</t>
<section title="Terminology" anchor="terminology">
<t>
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD",
"SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in <xref target="RFC2119"/>.
</t>
</section>
</section>
<section title="Syntax Convention" anchor="syntax.convention">
<section title="Examples" anchor="examples">
<t>
In the interest of clarity and readability, the extended parameters or the header fields and parameters in the examples in this document might be broken into multiple lines. Any line that is indented in this document is a continuation of the preceding line.
</t>
</section>
<section title="ABNF" anchor="abnf">
<t>
This specification uses the Augmented Backus-Naur Form (ABNF) notation of <xref target="RFC5234"/> and the ABNF List Extension of <xref target="RFC7230"/>.
</t>
</section>
</section>

<section title="Digest Access Authentication Scheme" anchor="digest.access.authentication.scheme">
<section title="Overall Operation" anchor="overall.operation">
<t>
The Digest scheme is based on a simple challenge-response paradigm. The Digest scheme challenges using a nonce value and might indicate that username hashing is supported. A valid response contains an unkeyed digest of the username, the password, the given nonce value, the HTTP method, and the requested URI. In this way, the password is never sent in the clear, and the username can be hashed, depending on the indication received from the server. The username and password must be prearranged in some fashion not addressed by this document.
</t>
</section>
<section title="Representation of Digest Values" anchor="representation.of.digest.values">

<t>
An optional header field allows the server to specify the algorithm used to create the unkeyed digest or digest. This document adds SHA-256 and SHA-512/256 algorithms. To maintain backwards compatibility with <xref target="RFC2617"/>, the MD5 algorithm is still supported but &NOT-RECOMMENDED;.
</t>
<t>
The size of the digest depends on the algorithm used. The bits in the digest
are converted from the most significant to the least significant bit, four
bits at a time, to the ASCII representation as follows. Each sequence of four bits is represented by its familiar hexadecimal notation from the characters 0123456789abcdef; that is, binary 0000 is represented by the character '0', 0001 by '1' and so on up to the representation of 1111 as 'f'. If the MD5 algorithm is used to calculate the digest, then the MD5 digest will be represented as 32 hexadecimal characters, while SHA-256 and SHA-512/256 are represented as 64 hexadecimal characters.
</t>
</section>
<section title="The WWW-Authenticate Response Header Field"
	 anchor="www-authenticate.response.header">



<t>
If a server receives a request for an access-protected object, and an acceptable Authorization header field is not sent, the server responds with a "401 Unauthorized" status code and a WWW-Authenticate header field with Digest scheme as per the framework defined above. The value of the header field can include parameters from the following list:
</t>
<t>realm
<list><t>
A string to be displayed to users so they know which username and password to
use. This string should contain at least the name of the host performing the
authentication and might additionally indicate the collection of users who
might have access.



An example is "registered_users@example.com". (See <xref target="RFC7235" x:sec="2.2"/> for more details.)
</t></list></t>
<t>domain
<list><t>
A quoted, space-separated list of URIs, as specified in <xref target="RFC3986"/>, that define the protection space. If a URI is a path-absolute, it is relative to the canonical root URL. (See <xref target="RFC7235" x:sec="2.2"/>.) An absolute-URI in this list may refer to a different server than the web-origin <xref target="RFC6454"/>. The client can use this list to determine the set of URIs for which the same authentication information may be sent: any URI that has a URI in this list as a prefix (after both have been made absolute) &MAY; be assumed to be in the same protection space. If this parameter is omitted or its value is empty, the client &SHOULD; assume that the protection space consists of all URIs on the web-origin.
</t>
<t>
This parameter is not meaningful in Proxy-Authenticate header fields, for which the protection space is always the entire proxy; if present, it &MUST; be ignored.
</t></list></t>
<t>nonce

<list><t>
A server-specified string which should be uniquely generated each time a 401 response is made. It is advised that this string be Base64 or hexadecimal data. Specifically, since the string is passed in the header field lines as a quoted string, the double-quote character is not allowed, unless suitably escaped.
</t>


<t>
The contents of the nonce are implementation dependent. The quality of the
implementation depends on a good choice. A nonce might, for example, be
constructed as the Base64 encoding of

<figure><artwork type="example">
         timestamp H(timestamp ":" ETag ":" secret-data)
</artwork></figure>
</t>
<t>
where timestamp is a server-generated time, which preferably includes micro-
or nanoseconds, or other non-repeating values; ETag is the value of the HTTP
ETag header field associated with the requested entity; and secret-data is
data known only to the server. With a nonce of this form, a server would
recalculate the hash portion after receiving the client authentication header
field and reject the request if it did not match the nonce from that header
field or if the timestamp value is not recent enough. In this way, the server
can limit the time of the nonce's validity. The inclusion of the ETag prevents
a replay request for an updated version of the resource. Including the IP
address of the client in the nonce would appear to offer the server the
ability to limit the reuse of the nonce to the same client that originally got
it.


However, that would break because requests from a single user often go through different proxies. Also, IP address spoofing is not that hard.
</t>
<t>
An implementation might choose not to accept a previously used nonce or a previously used digest, in order to protect against a replay attack. Or, an implementation might choose to use one-time nonces or digests for POST or PUT requests and a timestamp for GET requests. For more details on the issues involved, see <xref target="security.considerations"/> of this document.
</t>
<t>
The nonce is opaque to the client.
</t></list>
</t>
<t>opaque
<list><t>
A string of data, specified by the server, that &SHOULD; be returned by the client unchanged in the Authorization header field of subsequent requests with URIs in the same protection space. It is &RECOMMENDED; that this string be Base64 or hexadecimal data.
</t></list>
</t>
<t>stale
<list><t>
A case-insensitive flag indicating that the previous request from the client was rejected because the nonce value was stale. If stale is true, the client may wish to simply retry the request with a new encrypted response, without re-prompting the user for a new username and password. The server &SHOULD; only set stale to true if it receives a request for which the nonce is invalid. If stale is false, or anything other than true, or the stale parameter is not present, the username and/or password are invalid, and new values &MUST; be obtained.
</t></list>
</t>
<t>algorithm
<list><t>
A string indicating an algorithm used to produce the digest and an unkeyed digest. If this is not present, it is assumed to be "MD5". If the algorithm is not understood, the challenge &SHOULD; be ignored (and a different one used, if there is more than one).
</t>
<t>
When used with the Digest mechanism, each one of the algorithms has two variants: Session variant and non-Session variant. The non-Session variant is denoted by "&lt;algorithm>", e.g., "SHA-256", and the Session variant is denoted by "&lt;algorithm>-sess", e.g., "SHA-256-sess".
</t>
<t>
In this document, the string obtained by applying the digest algorithm to the data "data" with secret "secret" will be denoted by KD(secret, data), and the string obtained by applying the unkeyed digest algorithm to the data "data" will be denoted H(data). KD stands for Keyed Digest, and the notation unq(X) means the value of the quoted-string X without the surrounding quotes and with quoting slashes removed.

<figure><artwork type="inline">
     For "&lt;algorithm>" and "&lt;algorithm>-sess"

         H(data) = &lt;algorithm>(data)

     and

         KD(secret, data) = H(concat(secret, ":", data))
</artwork></figure>
</t>

<t>
For example:
<figure><artwork type="inline">
     For the "SHA-256" and "SHA-256-sess" algorithms

         H(data) = SHA-256(data)
</artwork></figure>
</t>
<t>
i.e., the digest is the "&lt;algorithm>" of the secret concatenated with a colon concatenated with the data.
The "&lt;algorithm>-sess" is intended to allow efficient third-party authentication servers; for the difference in usage, see the description in <xref target="a1"/>.
</t>
</list>
</t>

<t>qop
<list><t>
      This parameter &MUST; be used by all implementations. It is a quoted
      string of one or more tokens indicating the "quality of
      protection" values supported by the server. The value "auth"
      indicates authentication; the value "auth-int" indicates
      authentication with integrity protection. See the descriptions
      below for calculating the response parameter value for the
      application of this choice. Unrecognized options &MUST; be ignored.
</t></list>
</t>

<t>charset
<list><t>
This is an &OPTIONAL; parameter that is used by the server to indicate the
encoding scheme it supports. The only allowed value is "UTF-8".
</t></list>
</t>
<t>
userhash
<list>
<t>
This is an &OPTIONAL; parameter that is used by the server to indicate that it supports username hashing. Valid values are: "true" or "false". Default value is "false".
</t>
</list>
</t>

<t>
For historical reasons, a sender &MUST; only generate the quoted string syntax values for the following parameters: realm, domain, nonce, opaque, and qop.
</t>


<t>
For historical reasons, a sender &MUST-NOT; generate the quoted string syntax values for the following parameters: stale and algorithm.
</t>


</section>
<section title="The Authorization Header Field" anchor="authorization.request.header.field">
<t>
The client is expected to retry the request, passing an Authorization header field line with Digest scheme, which is defined according to the framework above. The values of the opaque and algorithm fields must be those supplied in the WWW-Authenticate response header field for the entity being requested.
</t>
<t>
The request can include parameters from the following list:
</t>
<t>response
<list><t>
A string of the hex digits computed as defined below; it proves that the user knows a password.
</t></list>
</t>



<t>username
<list><t>
      The user's name in the specified realm. The quoted string contains
      the name in plaintext or the hash code in hexadecimal notation.
      If the username contains characters not allowed inside the ABNF
      quoted-string production, the username* parameter can be used.
      Sending both username and username* in the same header option
      &MUST; be treated as an error.
</t></list>
</t>

<t>username*
<list><t>
 If the userhash parameter value is set "false" and the username
      contains characters not allowed inside the ABNF quoted-string
      production, the user's name can be sent with this parameter, using
      the extended notation defined in <xref target="RFC5987"/>.
</t></list>
</t>

<t>realm
<list><t>
See "realm" definition in <xref target="www-authenticate.response.header"/>.
</t></list>
</t>


<t>uri
<list><t>
The Effective Request URI (<xref target="RFC7230" x:sec="5.5"/>) of the HTTP request; duplicated here because proxies are allowed to change the request target ("request-target", <xref target="RFC7230" x:sec="3.1.1"/>) in transit.
</t></list>
</t>
<t>qop
<list><t>
Indicates what "quality of protection" the client has applied to the message. Its value &MUST; be one of the alternatives the server indicated it supports in the WWW-Authenticate header field. These values affect the computation of the response. Note that this is a single token, not a quoted list of alternatives as in WWW-Authenticate.
</t></list>
</t>
<t>cnonce
<list><t>
This parameter &MUST; be used by all implementations. The cnonce value is an opaque quoted ASCII-only string value provided by the client and used by both client and server to avoid chosen plaintext attacks, to provide mutual authentication, and to provide some message integrity protection. See the descriptions below of the calculation of the rspauth and response values.
</t></list>
</t>
<t>nc
<list><t>
This parameter &MUST; be used by all implementations. The nc parameter stands for "nonce count". The nc value is the hexadecimal count of the number of requests (including the current request) that the client has sent with the nonce value in this request. For example, in the first request sent in response to a given nonce value, the client sends "nc=00000001". The purpose of this parameter is to allow the server to detect request replays by maintaining its own copy of this count -- if the same nc value is seen twice, then the request is a replay. See the description below of the construction of the response value.
</t></list>
</t>
<t>
<vspace blankLines="3" />
</t>

<t>userhash
<list><t>
This &OPTIONAL; parameter is used by the client to indicate that the username has been hashed. Valid values are: "true" or "false". Default value is "false".
</t></list>
</t>

<t>
For historical reasons, a sender &MUST; only generate the quoted string
syntax for the following parameters: username, realm, nonce, uri,
response, cnonce, and opaque.
</t>

<t>
For historical reasons, a sender &MUST-NOT; generate the quoted string
syntax for the following parameters: algorithm, qop, and nc.
</t>


<t>
If a parameter or its value is improper, or required parameters are missing, the proper response is a 4xx error code. If the response is invalid, then a login failure &SHOULD; be logged, since repeated login failures from a single client may indicate an attacker attempting to guess passwords. The server implementation &SHOULD; be careful with the information being logged so that it won't put a cleartext password (e.g., entered into the username field) into the log.
</t>


<t>
The definition of the response above indicates the encoding for its value. The following definitions show how the value is computed.
</t>
<section title="Response" anchor="response">
<t>
If the qop value is "auth" or "auth-int":
</t>
<figure><artwork type="inline">
      response = &lt;"> &lt; KD ( H(A1), unq(nonce)
                                   ":" nc
                                   ":" unq(cnonce)
                                   ":" unq(qop)
                                   ":" H(A2)
                          ) &lt;">
</artwork></figure>
<t>
See below for the definitions for A1 and A2.
</t>
</section>
<section title="A1" anchor="a1">

<t>
If the algorithm parameter's value is "&lt;algorithm>", e.g., "SHA&nbhy;256", then A1 is:
</t>
<figure><artwork type="inline">
      A1       = unq(username) ":" unq(realm) ":" passwd
</artwork></figure>
<t>
   where
</t>
<figure><artwork type="inline">
      passwd   = &lt; user's password >
</artwork></figure>
<t>
If the algorithm parameter's value is "&lt;algorithm>-sess", e.g., "SHA-256-sess", then A1 is calculated using the nonce value provided in the challenge from the server, and cnonce value from the request by the client following receipt of a WWW-Authenticate challenge from the server. It uses the server nonce from that challenge, herein called nonce-prime, and the client nonce value from the response, herein called cnonce-prime, to construct A1 as follows:
</t>
<figure><artwork type="inline">
      A1       = H( unq(username) ":" unq(realm) ":" passwd )
                     ":" unq(nonce-prime) ":" unq(cnonce-prime)
</artwork></figure>
<t>
This creates a "session key" for the authentication of subsequent requests and responses that is different for each "authentication session", thus limiting the amount of material hashed with any one key. (Note: see further discussion of the authentication session in <xref target="digest.operation"/>.) Because the server needs only use the hash of the user credentials in order to create the A1 value, this construction could be used in conjunction with a third-party authentication service so that the web server would not need the actual password value. The specification of such a protocol is beyond the scope of this specification.
</t>
</section>
<section title="A2">
<t>
If the qop parameter's value is "auth" or is unspecified, then A2 is:
</t>
<figure><artwork type="inline">
      A2       = Method ":" request-uri
</artwork></figure>
<t>
   If the qop value is "auth-int", then A2 is:
</t>
<figure><artwork type="inline">
      A2       = Method ":" request-uri ":" H(entity-body)
</artwork></figure>
</section>
<section title="Username Hashing" anchor="username.hashing">
<t>
To protect the transport of the username from the client to the server, the server &SHOULD; set the userhash parameter with the value of "true" in the WWW-Authentication header field.
</t>
<t>
If the client supports the userhash parameter, and the userhash parameter value in the WWW-Authentication header field is set to "true", then the client &MUST; calculate a hash of the username after any other hash calculation and include the userhash parameter with the value of "true" in the Authorization header field. If the client does not provide the username as a hash value or the userhash parameter with the value of "true", the server &MAY; reject the request.
</t>
<t>
The following is the operation that the client will perform to hash the username, using the same algorithm used to hash the credentials:
</t>
<figure><artwork type="inline">
   username = H( unq(username) ":" unq(realm) )
</artwork></figure>
</section>
<section title="Parameter Values and Quoted-String">
<t>
Note that the value of many of the parameters, such as username value, are defined as a "quoted-string". However, the "unq" notation indicates that surrounding quotation marks are removed in forming the string A1. Thus, if the Authorization header field includes the fields
</t>
<figure><artwork type="example">
   username="Mufasa", realm="myhost@example.com"
</artwork></figure>
<t>
and the user Mufasa has password "Circle Of Life", then H(A1) would be H(Mufasa:myhost@example.com:Circle Of Life) with no quotation marks in the digested string.
</t>
<t>
No white space is allowed in any of the strings to which the digest function H() is applied, unless that white space exists in the quoted strings or entity body whose contents make up the string to be digested. For example, the string A1 illustrated above must be
</t>
<figure><artwork type="example">
   Mufasa:myhost@example.com:Circle Of Life
</artwork></figure>
<t>
with no white space on either side of the colons, but with the white space between the words used in the password value. Likewise, the other strings digested by H() must not have white space on either side of the colons that delimit their fields, unless that white space was in the quoted strings or entity body being digested.
</t>
<t>
Also, note that if integrity protection is applied (qop=auth-int), the H(entity-body) is the hash of the entity body, not the message body -- it is computed before any transfer encoding is applied by the sender and after it has been removed by the recipient. Note that this includes multipart boundaries and embedded header fields in each part of any multipart content-type.
</t>
</section>
<section title="Various Considerations">
<t>
The "Method" value is the HTTP request method, in US-ASCII letters, as specified in <xref target="RFC7230" x:sec="3.1.1"/>. The "request-target" value is the request-target from the request line as specified in <xref target="RFC7230" x:sec="3.1.1"/>. This &MAY; be "*", an "absolute-URI", or an "absolute-path" as specified in <xref target="RFC7230" x:sec="2.7"/>, but it &MUST; agree with the request-target. In particular, it &MUST; be an "absolute-URI" if the request-target is an "absolute-URI". The cnonce value is a client-chosen value whose purpose is to foil chosen plaintext attacks.
</t>
<t>
The authenticating server &MUST; assure that the resource designated by the "uri" parameter is the same as the resource specified in the Request-Line; if they are not, the server &SHOULD; return a 400 Bad Request error. (Since this may be a symptom of an attack, server implementers may want to consider logging such errors.) The purpose of duplicating information from the request URL in this field is to deal with the possibility that an intermediate proxy may alter the client's Request-Line. This altered (but presumably semantically equivalent) request would not result in the same digest as that calculated by the client.
</t>
<t>
Implementers should be aware of how authenticated transactions need to interact with shared caches (see <xref target="RFC7234"/>).
</t>
</section>
</section>
<section title="The Authentication-Info and Proxy-Authentication-Info Header Fields" anchor="authenticaion-info.header.field">
<t>
The Authentication-Info header field and the Proxy-Authentication-Info header field <xref target="RFC7615"/> are generic fields that &MAY; be used by a server to communicate some information regarding the successful authentication of a client response.
</t>
<t>
The Digest Authentication scheme &MAY; add the Authentication-Info header field in the confirmation request and include parameters from the following list:
</t>
<t>nextnonce
<list><t>
The value of the nextnonce parameter is the nonce the server wishes the client
to use for a future authentication response.


The server &MAY; send the Authentication-Info header field with a nextnonce
field as a means of implementing one-time nonces or otherwise changing nonces. If the nextnonce field is present, the client &SHOULD; use it when constructing the Authorization header field for its next request. Failure of the client to do so &MAY; result in a request to re-authenticate from the server with the "stale=true".
<list><t>
Server implementations &SHOULD; carefully consider the performance implications of the use of this mechanism; pipelined requests will not be possible if every response includes a nextnonce parameter that &MUST; be used on the next request received by the server. Consideration &SHOULD; be given to the performance vs. security tradeoffs of allowing an old nonce value to be used for a limited time to permit request pipelining. Use of the nc parameter can retain most of the security advantages of a new server nonce without the deleterious effects on pipelining.
</t></list>
</t></list>
</t>
<t>qop
<list><t>
Indicates the "quality of protection" options applied to the response by the server. The value "auth" indicates authentication; the value "auth-int" indicates authentication with integrity protection. The server &SHOULD; use the same value for the qop parameter in the response as was sent by the client in the corresponding request.
</t></list>
</t>
<t>rspauth
<list><t>
The optional response digest in the rspauth parameter supports mutual
authentication -- the server proves that it knows the user's secret, and with
qop=auth-int also provides limited integrity protection of the response. The
rspauth value is calculated as for the response in the Authorization header
field, except that if qop is set to "auth" or is not specified in the Authorization header field for the request, A2 is
</t>
<t>
<figure><artwork type="inline">
      A2       = ":" request-uri
</artwork></figure>

   and if "qop=auth-int", then A2 is

<figure><artwork type="inline">
      A2       = ":" request-uri ":" H(entity-body)
</artwork></figure>
</t></list>
</t>


<t>cnonce and nc
<list><t>
The cnonce value and nc value &MUST; be the ones for the client request to which this message is the response. The rspauth, cnonce, and nc parameters &MUST; be present if "qop=auth" or "qop=auth-int" is specified.
</t></list>
</t>
<t>
The Authentication-Info header field is allowed in the trailer of an HTTP
message transferred via chunked transfer coding.
</t>

<t>
For historical reasons, a sender &MUST; only generate the quoted string
syntax for the following parameters: nextnonce, rspauth, and cnonce.
</t>

<t>
For historical reasons, a sender &MUST-NOT; generate the quoted string
syntax for the following parameters: qop and nc.
</t>

<t>
For historical reasons, the nc value &MUST; be exactly 8 hexadecimal digits.
</t>

</section>

<section title="Digest Operation" anchor="digest.operation">
<t>
Upon receiving the Authorization header field, the server &MAY; check its validity by looking up the password that corresponds to the submitted username. Then, the server &MUST; perform the same digest operation (e.g., MD5, SHA-256) performed by the client and compare the result to the given response value.
</t>
<t>
Note that the HTTP server does not actually need to know the user's cleartext password. As long as H(A1) is available to the server, the validity of an Authorization header field can be verified.
</t>
<t>
The client response to a WWW-Authenticate challenge for a protection space
starts an authentication session with that protection space. The
authentication session lasts until the client receives another
WWW-Authenticate challenge from any server in the protection space. A client
&SHOULD; remember the username, password, nonce, nonce count, and opaque values
associated with an authentication session to use to construct the
Authorization header field in future requests within that protection
space. The Authorization header field &MAY; be included preemptively; doing so
improves server efficiency and avoids extra round trips for authentication
challenges. The server &MAY; choose to accept the old Authorization header field
information, even though the nonce value included might not be
fresh. Alternatively, the server &MAY; return a 401 response with a new nonce
value in the WWW-Authenticate header field, causing the client to retry the request; by specifying "stale=true" with this response, the server tells the client to retry with the new nonce, but without prompting for a new username and password.
</t>
<t>
Because the client is required to return the value of the opaque parameter given to it by the server for the duration of a session, the opaque data can be used to transport authentication session state information. (Note that any such use can also be accomplished more easily and safely by including the state in the nonce.) For example, a server could be responsible for authenticating content that actually sits on another server. It would achieve this by having the first 401 response include a domain parameter whose value includes a URI on the second server, and an opaque parameter whose value contains the state information. The client will retry the request, at which time the server might respond with "HTTP Redirection" (<xref target="RFC7231" x:sec="6.4"/>), pointing to the URI on the second server. The client will follow the redirection and pass an Authorization header field, including the &lt;opaque> data.
</t>
<t>
Proxies &MUST; be completely transparent in the Digest access authentication scheme. That is, they &MUST; forward the WWW-Authenticate, Authentication-Info, and Authorization header fields untouched. If a proxy wants to authenticate a client before a request is forwarded to the server, it can be done using the Proxy-Authenticate and Proxy-Authorization header fields described in <xref target="proxy-auth"/> below.
</t>
</section>
<section title="Security Protocol Negotiation">
<t>
It is useful for a server to be able to know which security schemes a client is capable of handling.
</t>
<t>
It is possible that a server wants to require Digest as its authentication method, even if the server does not know that the client supports it. A client is encouraged to fail gracefully if the server specifies only authentication schemes it cannot handle.
</t>
<t>
When a server receives a request to access a resource, the server might challenge the client by responding with "401 Unauthorized" response and include one or more WWW-Authenticate header fields. If the server responds with multiple challenges, then each one of these challenges &MUST; use a different digest algorithm. The server &MUST; add these challenges to the response in order of preference, starting with the most preferred algorithm, followed by the less preferred algorithm.
</t>
<t>
This specification defines the following algorithms:
<list style="symbols">
<t>SHA2-256 (mandatory to implement)</t>
<t>SHA2-512/256 (as a backup algorithm)</t>
<t>MD5 (for backward compatibility).</t>
</list>
</t>
<t>
When the client receives the first challenge, it &SHOULD; use the first challenge it supports, unless a local policy dictates otherwise.
</t>
</section>
<section title="Proxy-Authenticate and Proxy-Authorization" anchor="proxy-auth">
<t>
The Digest Authentication scheme can also be used for authenticating users to
proxies, proxies to proxies, or proxies to origin servers by use of the
Proxy-Authenticate and Proxy-Authorization header fields.



These header fields are instances of the Proxy-Authenticate and Proxy-Authorization header fields specified in Sections <xref target="RFC7235" x:sec="4.3" x:fmt="number"/> and <xref target="RFC7235" x:sec="4.4" x:fmt="number"/> of the HTTP/1.1 specification <xref target="RFC7235"/>, and their behavior is subject to restrictions described there. The transactions for proxy authentication are very similar to those already described. Upon receiving a request that requires authentication, the proxy/server &MUST; issue the "407 Proxy Authentication Required" response with a "Proxy-Authenticate" header field. The digest-challenge used in the Proxy-Authenticate header field is the same as that for the WWW-Authenticate header field as defined above in <xref target="www-authenticate.response.header"/>.
</t>

<!-- [rfced] Are these terms equivalent?
"Authorization header field" and "Authorization Request header field"
The reason for the question is comparing the following text with
the title of Section 3.4 ("Authorization Request Header Field").

Original:
   The client/proxy MUST then re-issue the request with a Proxy-
   Authorization header field, with parameters as specified for the
   Authorization header field in Section 3.4 above.
-->

<t>
The client/proxy &MUST; then reissue the request with a Proxy-Authorization header field, with parameters as specified for the Authorization header field in <xref target="authorization.request.header.field"/> above.
</t>
<t>
On subsequent responses, the server sends Proxy-Authentication-Info with parameters the same as those for the Authentication-Info header field.
</t>
<t>
Note that, in principle, a client could be asked to authenticate itself to both a proxy and an end-server, but never in the same response.
</t>
</section>
<section title="Examples">
<section title="Example with SHA-256 and MD5">
<t>
The following example assumes that an access-protected document is being requested from the server via a GET request. The URI of the document is "http://www.example.org/dir/index.html". Both client and server know that the username for this document is "Mufasa" and the password is "Circle of Life" (with one space between each of the three words).
</t>
<t>
The first time the client requests the document, no Authorization header field is sent, so the server responds with:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;">
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest
    realm="http-auth@example.org",
    qop="auth, auth-int",
    algorithm=SHA-256,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
WWW-Authenticate: Digest
    realm="http-auth@example.org",
    qop="auth, auth-int",
    algorithm=MD5,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
</artwork></figure>
<t>
The client can prompt the user for their username and password, after which it will respond with a new request, including the following Authorization header field if the client chooses MD5 digest:
</t>
<figure><artwork type="example">
Authorization: Digest username="Mufasa",
    realm="http-auth@example.org",
    uri="/dir/index.html",
    algorithm=MD5,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    nc=00000001,
    cnonce="f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ",
    qop=auth,
    response="8ca523f5e9506fed4657c9700eebdbec",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
</artwork></figure>

<t>
If the client chooses to use the SHA-256 algorithm for calculating the response, the client responds with a new request including the following Authorization header field:
</t>
<figure><artwork type="example">
Authorization: Digest username="Mufasa",
    realm="http-auth@example.org",
    uri="/dir/index.html",
    algorithm=SHA-256,
    nonce="7ypf/xlj9XXwfDPEoM4URrv/xwf94BcCAzFZH4GiTo0v",
    nc=00000001,
    cnonce="f2/wE4q74E6zIJEtWaHKaf5wv/H5QzzpXusqGemxURZJ",
    qop=auth,
    response="753927fa0e85d155564e2e272a28d1802ca10daf449
       6794697cf8db5856cb6c1",
    opaque="FQhe/qaU925kfnzjCev0ciny7QMkPqMAFRtzCUYo5tdS"
</artwork></figure>
</section>
<section title="Example with SHA-512-256, Charset, and Userhash">
<t>
The following example assumes that an access-protected document is
being requested from the server via a GET request.  The URI for the
request is "http://api.example.org/doe.json".  Both client and server
know the userhash of the username, support the UTF-8 character
encoding scheme, and use the SHA-512-256 algorithm. The username for
the request is a variation of "Jason Doe", where the 'a' actually
is Unicode code point U+00E4 ("LATIN SMALL LETTER A WITH DIAERESIS"),
and the first 'o' is Unicode code point U+00F8 ("LATIN SMALL LETTER O
WITH STROKE"), leading to the octet sequence using the UTF-8 encoding scheme:
</t>

<t>
<figure><artwork type="example">
   J  U+00E4 s  U+00F8 n      D  o  e
   4A C3A4   73 C3B8   6E 20 44  6F 65
</artwork></figure>
</t>


<t>
The password is "Secret, or not?".
</t>
<t>
The first time the client requests the document, no Authorization header field is sent, so the server responds with:
</t>
<figure><artwork type="message/http; msgtype=&#34;response&#34;">
HTTP/1.1 401 Unauthorized
WWW-Authenticate: Digest
    realm="api@example.org",
    qop="auth",
    algorithm=SHA-512-256,
    nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
    opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
    charset=UTF-8,
    userhash=true
</artwork></figure>
<t>
The client can prompt the user for the required credentials and send a new request with following Authorization header field:
</t>
<figure><artwork type="example">
Authorization: Digest
    username="488869477bf257147b804c45308cd62ac4e25eb717
       b12b298c79e62dcea254ec",
    realm="api@example.org",
    uri="/doe.json",
    algorithm=SHA-512-256,
    nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
    nc=00000001,
    cnonce="NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v",
    qop=auth,
    response="ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d
       6c861229025f607a79dd",
    opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
    userhash=true
</artwork></figure>
<t>
If the client cannot provide a hashed username for any reason, the client can try a request with this Authorization header field:
</t>
<figure><artwork type="example">
Authorization: Digest
    username*=UTF-8''J%C3%A4s%C3%B8n%20Doe,
    realm="api@example.org",
    uri="/doe.json",
    algorithm=SHA-512-256,
    nonce="5TsQWLVdgBdmrQ0XsxbDODV+57QdFR34I9HAbC/RVvkK",
    nc=00000001,
    cnonce="NTg6RKcb9boFIAS3KrFK9BGeh+iDa/sm6jUMp2wds69v",
    qop=auth,
    response="ae66e67d6b427bd3f120414a82e4acff38e8ecd9101d
       6c861229025f607a79dd",
    opaque="HRPCssKJSGjCrkzDg8OhwpzCiGPChXYjwrI2QmXDnsOS",
    userhash=false
</artwork></figure>
</section>
</section>
</section>

<section title="Internationalization Considerations">
<t>
In challenges, servers &SHOULD; use the "charset" authentication parameter (case-insensitive) to express the character encoding they expect the user agent to use when generating A1 (see <xref target="a1"/>) and username hashing (see <xref target="username.hashing"/>).
</t>
<t>
The only allowed value is "UTF-8", to be matched case-insensitively (see
<xref target="RFC2978" x:sec="2.3" x:fmt="sec"/> in <xref target="RFC2978"/>). It indicates that the server expects the username and password to be converted to Unicode Normalization Form C ("NFC", see <xref target="RFC5198" x:sec="3"/>) and to be encoded into octets using the UTF-8 character encoding scheme <xref target="RFC3629"/>.
</t>
<t>
For the username, recipients &MUST; support all characters defined in the "UsernameCasePreserved" profile defined in <xref target="RFC7613" x:sec="3.3"/>, with the exception of the colon (":") character.
</t>
<t>
For the password, recipients &MUST; support all characters defined in the "OpaqueString" profile defined in <xref target="RFC7613" x:sec="4.2"/>.
</t>
<t>
If the user agent does not support the encoding indicated by the server, it can fail the request.
</t>
<t>
When usernames cannot be sent hashed and include non-ASCII characters, clients can include the username* parameter instead (using the value encoding defined in <xref target="RFC5987"/>).
</t>
</section>

<section title="Security Considerations" anchor="security.considerations">
<section title="Limitations">
<t>
HTTP Digest Authentication, when used with human-memorable passwords,
is vulnerable to dictionary attacks. Such attacks are much easier
than cryptographic attacks on any widely used algorithm, including
those that are no longer considered secure. In other words, algorithm
agility does not make this usage any more secure.
</t>
<t>
As a result, Digest Authentication &SHOULD; be used only with passwords
that have a reasonable amount of entropy, e.g., 128-bit or more. Such
passwords typically cannot be memorized by humans but can be used for
automated web services.
</t>
<t>
If Digest Authentication is being used, it &SHOULD; be over a secure channel like HTTPS <xref target="RFC2818"/>.
</t>
</section>
<section title="Storing Passwords">
<t>
Digest Authentication requires that the authenticating agent (usually
the server) store some data derived from the user's name and password
in a "password file" associated with a given realm. Normally, this
might contain pairs consisting of username and H(A1), where H(A1) is
the digested value of the username, realm, and password as described
above.
</t>
<t>
The security implications of this are that if this password file is
compromised, then an attacker gains immediate access to documents on
the server using this realm. Unlike, say, a standard UNIX password
file, this information needs not be decrypted in order to access
documents in the server realm associated with this file. On the other
hand, decryption, or more likely a brute-force attack, would be
necessary to obtain the user's password. This is the reason that the
realm is part of the digested data stored in the password file. It
means that if one Digest Authentication password file is compromised,
it does not automatically compromise others with the same username
and password (though it does expose them to brute-force attack).
</t>
<t>
There are two important security consequences of this. First, the
password file must be protected as if it contained unencrypted
passwords, because, for the purpose of accessing documents in its
realm, it effectively does.
</t>
<t>
A second consequence of this is that the realm string &SHOULD; be
unique among all realms that any single user is likely to use. In
particular, a realm string &SHOULD; include the name of the host doing
the authentication. The inability of the client to authenticate the
server is a weakness of Digest Authentication.
</t>
</section>
<section title="Authentication of Clients Using Digest Authentication">
<t>
Digest Authentication does not provide a strong authentication
mechanism, when compared to public-key-based mechanisms, for example.
</t>
<t>
However, it is significantly stronger than, e.g., CRAM-MD5, which has been
proposed for use with Lightweight Directory Access Protocol (LDAP) <xref target="RFC4513"/> and IMAP/POP (see <xref target="RFC2195"/>). It was intended to replace the much weaker and even more
dangerous Basic mechanism.
</t>
<t>
Digest Authentication offers no confidentiality protection beyond protecting the actual username and password. All of the rest of the request and response are available to an eavesdropper.
</t>
<t>
Digest Authentication offers only limited integrity protection for the
messages in either direction. If the "qop=auth-int" mechanism is used, those parts of the message used in the calculation of the WWW-Authenticate and Authorization header field response parameter values (see <xref target="representation.of.digest.values"/> above) are protected. Most header fields and their values could be modified as a part of a man-in-the-middle attack.
</t>
<t>
Many needs for secure HTTP transactions cannot be met by Digest
Authentication. For those needs, TLS is a more appropriate protocol. In particular, Digest Authentication cannot be used for any transaction requiring confidentiality protection. Nevertheless, many functions remain for which Digest Authentication is both useful and appropriate.
</t>
</section>

<section title="Limited-Use Nonce Values">
<t>
The Digest scheme uses a server-specified nonce to seed the
generation of the response value (as specified in <xref target="response"/> above).
As shown in the example nonce in <xref target="www-authenticate.response.header"/>, the
server is free to construct the nonce such that it &MAY; only be used
from a particular client, for a particular resource, for a limited
period of time or number of uses, or any other restrictions. Doing
so strengthens the protection provided against, for example, replay
attacks (see <xref target="replay_attacks"/>). However, it should be noted that the method
chosen for generating and checking the nonce also has performance and
resource implications. For example, a server &MAY; choose to allow
each nonce value to be used only once by maintaining a record of
whether or not each recently issued nonce has been returned and
sending a next-nonce parameter in the Authentication-Info header
field of every response. This protects against even an immediate
replay attack, but it has a high cost due to checking nonce values; perhaps
more important, it will cause authentication failures for any pipelined
requests (presumably returning a stale nonce indication). Similarly,
incorporating a request-specific element such as the ETag value for a
resource limits the use of the nonce to that version of the resource
and also defeats pipelining. Thus, it &MAY; be useful to do so for
methods with side effects but have unacceptable performance for those
that do not.
</t>
</section>
<section title="Replay Attacks" anchor="replay_attacks">


<t>
A replay attack against Digest Authentication would usually be
pointless for a simple GET request since an eavesdropper would
already have seen the only document he could obtain with a replay.
This is because the URI of the requested document is digested in the
client request, and the server will only deliver that document. By
contrast, under Basic Authentication, once the eavesdropper has the
user's password, any document protected by that password is open to
him.
</t>
<t>
Thus, for some purposes, it is necessary to protect against replay
attacks. A good Digest implementation can do this in various ways.
The server-created "nonce" value is implementation dependent, but if
it contains a digest of the client IP, a timestamp, the resource
ETag, and a private server key (as recommended above), then a replay
attack is not simple. An attacker must convince the server that the
request is coming from a false IP address and must cause the server
to deliver the document to an IP address different from the address
to which it believes it is sending the document. An attack can only
succeed in the period before the timestamp expires. Digesting the
client IP and timestamp in the nonce permits an implementation that
does not maintain state between transactions.
</t>
<t>
For applications where no possibility of replay attack can be
tolerated, the server can use one-time nonce values that will not be
honored for a second use. This requires the overhead of the server remembering which nonce values have been used until the nonce timestamp (and hence the digest built with it) has expired, but it
effectively protects against replay attacks.
</t>
<t>
An implementation must give special attention to the possibility of
replay attacks with POST and PUT requests.



Unless the server employs
one-time or otherwise limited-use nonces and/or insists on the use of
the integrity protection of "qop=auth-int", an attacker could replay
valid credentials from a successful request with counterfeit
data or other message body. Even with the use of integrity protection,
most metadata in header fields is not protected.

Proper nonce
generation and checking provides some protection against replay of
previously used valid credentials, but see <xref target="mitm"/>.
</t>
</section>
<section title="Weakness Created by Multiple Authentication Schemes">

<t>
An HTTP/1.1 server &MAY; return multiple challenges with a 401
(Authenticate) response, and each challenge &MAY; use a different
auth-scheme. A user agent &MUST; choose to use the strongest auth-scheme it understands and request credentials from the user based
upon that challenge.
</t>
<t>
When the server offers choices of authentication schemes using the
WWW-Authenticate header field, the strength of the resulting authentication
is only as good as that of the of the weakest of the authentication
schemes. See <xref target="online.dictionary.attacks"/> below for discussion of particular attack
scenarios that exploit multiple authentication schemes.
</t>
</section>
<section title="Online Dictionary Attacks" anchor="online.dictionary.attacks">
<t>
If the attacker can eavesdrop, then it can test any overheard
nonce/response pairs against a list of common words. Such a list is
usually much smaller than the total number of possible passwords. The
cost of computing the response for each password on the list is paid
once for each challenge.
</t>
<t>
The server can mitigate this attack by not allowing users to select
passwords that are in a dictionary.
</t>
</section>
<section title="Man-in-the-Middle Attacks" anchor="mitm">
<t>
Digest Authentication is vulnerable to man-in-the-middle (MITM) attacks, for example, from a hostile or compromised proxy. Clearly, this would present all the problems of eavesdropping. But, it also offers some additional opportunities to the attacker.
</t>
<t>
A possible man-in-the-middle attack would be to add a weak
authentication scheme to the set of choices, hoping that the client
will use one that exposes the user's credentials (e.g., password). For
this reason, the client &SHOULD; always use the strongest scheme that
it understands from the choices offered.
</t>
<t>
An even better MITM attack would be to remove all offered choices,
replacing them with a challenge that requests only Basic
authentication, then uses the cleartext credentials from the Basic
authentication to authenticate to the origin server using the
stronger scheme it requested. A particularly insidious way to mount
such a MITM attack would be to offer a "free" proxy caching service
to gullible users.
</t>
<t>
User agents should consider measures such as presenting a visual
indication at the time of the credentials request of what
authentication scheme is to be used, or remembering the strongest
authentication scheme ever requested by a server and producing a
warning message before using a weaker one. It might also be a good
idea for the user agent to be configured to demand Digest
authentication in general or from specific sites.
</t>
<t>
Or, a hostile proxy might spoof the client into making a request the
attacker wanted rather than one the client wanted. Of course, this is
still much harder than a comparable attack against Basic
Authentication.
</t>
</section>
<section title="Chosen Plaintext Attacks">
<t>
With Digest Authentication, a MITM or a malicious server can
arbitrarily choose the nonce that the client will use to compute the
response. This is called a "chosen plaintext" attack. The ability to
choose the nonce is known to make cryptanalysis much easier.
</t>
<t>
However, a method to analyze the one-way functions used by Digest
using chosen plaintext is not currently known.
</t>
<t>
The countermeasure against this attack is for clients to use the cnonce parameter; this allows the client to vary the input to the hash in a way not chosen by the attacker.
</t>
</section>
<section title="Precomputed Dictionary Attacks">
<t>
With Digest Authentication, if the attacker can execute a chosen
plaintext attack, the attacker can precompute the response for many
common words to a nonce of its choice and store a dictionary of
response/password pairs. Such precomputation can often be done in
parallel on many machines. It can then use the chosen plaintext
attack to acquire a response corresponding to that challenge and
just look up the password in the dictionary. Even if most passwords
are not in the dictionary, some might be. Since the attacker gets to
pick the challenge, the cost of computing the response for each
password on the list can be amortized over finding many passwords. A
dictionary with 100 million password/response pairs would take about
3.2 gigabytes of disk storage.

</t>
<t>
The countermeasure against this attack is for clients to use the cnonce parameter.
</t>
</section>
<section title="Batch Brute-Force Attacks">
<t>
With Digest Authentication, a MITM can execute a chosen plaintext
attack and can gather responses from many users to the same nonce.
It can then find all the passwords within any subset of password
space that would generate one of the nonce/response pairs in a single
pass over that space. It also reduces the time to find the first
password by a factor equal to the number of nonce/response pairs
gathered. This search of the password space can often be done in
parallel on many machines, and even a single machine can search large
subsets of the password space very quickly -- reports exist of
searching all passwords with six or fewer letters in a few hours.
</t>
<t>
The countermeasure against this attack is for clients to use the cnonce parameter.
</t>
</section>

<section title="Parameter Randomness">
<t>
The security of this protocol is critically dependent on the randomness of the randomly chosen parameters, such as client and server nonces. These should be generated by a strong random or properly seeded pseudorandom source (see <xref target="RFC4086"/>).
</t>
</section>


<section title="Summary">
<t>
By modern cryptographic standards, Digest Authentication is weak. But,
for a large range of purposes, it is valuable as a replacement for
Basic Authentication. It remedies some, but not all, weaknesses of
Basic Authentication. Its strength may vary depending on the
implementation. In particular, the structure of the nonce (which is
dependent on the server implementation) may affect the ease of
mounting a replay attack. A range of server options is appropriate
since, for example, some implementations may be willing to accept the
server overhead of one-time nonces or digests to eliminate the
possibility of replay. Others may be satisfied with a nonce like the one
recommended above, i.e., restricted to a single IP address and a single ETag
or with a limited lifetime.
</t>
<t>
The bottom line is that *any* compliant implementation will be
relatively weak by cryptographic standards, but *any* compliant
implementation will be far superior to Basic Authentication.
</t>
</section>

</section>

<section title="IANA Considerations" anchor="iana.considerations">
<section title="Hash Algorithms for HTTP Digest Authentication ">
<t>
This specification creates a new IANA registry named "Hash Algorithms
for HTTP Digest Authentication" under the existing "Hypertext Transfer Protocol
(HTTP) Digest Algorithm Values" category.
This registry lists the hash algorithms that can be used in HTTP Digest Authentication.
</t>

<t>
When registering a new hash algorithm, the following information &MUST; be provided:
</t>
<t>Hash Algorithm
<list><t>
     The textual name of the hash algorithm.
</t></list></t>
<t>Digest Size
<list><t>
     The size of the algorithm's output in bits.
</t></list></t>
<t>Reference
<list><t>
     A reference to the specification adding the algorithm to this registry.
</t></list></t>
<t>
The update policy for this registry shall be Specification Required <xref target="RFC5226"/>.
</t>
<t>
The initial registry contains the following entries:
</t>
<texttable>
  <ttcol>Hash Algorithm</ttcol>
  <ttcol>Digest Size</ttcol>
  <ttcol>Reference</ttcol>
  <c>"MD5"</c><c>128</c><c>RFC 7616</c>
  <c>"SHA-512-256"</c><c>256</c><c>RFC 7616</c>
  <c>"SHA-256"</c><c>256</c><c>RFC 7616</c>
</texttable>
<t>
Each one of the algorithms defined in the registry might have a "-sess" variant, e.g., MD5-sess, SHA-256-sess, etc.
</t>

<t>
To clarify the purpose of the existing "HTTP Digest Algorithm Values" registry and
to avoid confusion between the two registries, IANA has added the following
description to the existing "HTTP Digest Algorithm Values" registry:

<list><t>
   This registry lists the algorithms that can be used when creating
   digests of an HTTP message body, as specified in RFC 3230.
</t></list>
</t>


</section>
<section title="Digest Scheme Registration">
<t>
This specification updates the existing entry of the Digest scheme in
the "Hypertext Transfer Protocol (HTTP) Authentication Scheme Registry" and adds a
new reference to this specification.
</t>
<t><list>
  <t>Authentication Scheme Name: Digest</t>
  <t>Pointer to specification text: RFC 7616</t>
</list></t>
</section>
</section>


  </middle>
  <back>

<references title="Normative References">


<reference anchor="RFC2119">
<front>
<title>Key words for use in RFCs to Indicate Requirement Levels</title>
<author initials="S." surname="Bradner" fullname="S. Bradner"><organization/></author>
<date year="1997" month="March"/>
<abstract><t>In many standards track documents several words are used to signify the requirements in the specification.  These words are often capitalized. This document defines these words as they should be interpreted in IETF documents.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name="BCP" value="14"/>
<seriesInfo name="RFC" value="2119"/>
<seriesInfo name="DOI" value="10.17487/RFC2119"/>
</reference>



<reference anchor="RFC2978">
<front>
<title>IANA Charset Registration Procedures</title>
<author initials="N." surname="Freed" fullname="N. Freed"><organization/></author>
<author initials="J." surname="Postel" fullname="J. Postel"><organization/></author>
<date year="2000" month="October"/>
<abstract><t>Multipurpose Internet Mail Extensions (MIME) and various other Internet protocols are capable of using many different charsets.  This in turn means that the ability to label different charsets is essential.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name="BCP" value="19"/>
<seriesInfo name="RFC" value="2978"/>
<seriesInfo name="DOI" value="10.17487/RFC2978"/>
</reference>



<reference anchor="RFC3629">
<front>
<title>UTF-8, a transformation format of ISO 10646</title>
<author initials="F." surname="Yergeau" fullname="F. Yergeau"><organization/></author>
<date year="2003" month="November"/>
<abstract><t>ISO/IEC 10646-1 defines a large character set called the Universal Character Set (UCS) which encompasses most of the world's writing systems.  The originally proposed encodings of the UCS, however, were not compatible with many current applications and protocols, and this has led to the development of UTF-8, the object of this memo.  UTF-8 has the characteristic of preserving the full US-ASCII range, providing compatibility with file systems, parsers and other software that rely on US-ASCII values but are transparent to other values.  This memo obsoletes and replaces RFC 2279.</t></abstract>
</front>
<seriesInfo name="STD" value="63"/>
<seriesInfo name="RFC" value="3629"/>
<seriesInfo name="DOI" value="10.17487/RFC3629"/>
</reference>



<reference anchor="RFC3986">
<front>
<title>Uniform Resource Identifier (URI): Generic Syntax</title>
<author initials="T." surname="Berners-Lee" fullname="T. Berners-Lee"><organization/></author>
<author initials="R." surname="Fielding" fullname="R. Fielding"><organization/></author>
<author initials="L." surname="Masinter" fullname="L. Masinter"><organization/></author>
<date year="2005" month="January"/>
<abstract><t>A Uniform Resource Identifier (URI) is a compact sequence of characters that identifies an abstract or physical resource.  This specification defines the generic URI syntax and a process for resolving URI references that might be in relative form, along with guidelines and security considerations for the use of URIs on the Internet.  The URI syntax defines a grammar that is a superset of all valid URIs, allowing an implementation to parse the common components of a URI reference without knowing the scheme-specific requirements of every possible identifier.  This specification does not define a generative grammar for URIs; that task is performed by the individual specifications of each URI scheme.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name="STD" value="66"/>
<seriesInfo name="RFC" value="3986"/>
<seriesInfo name="DOI" value="10.17487/RFC3986"/>
</reference>



<reference anchor="RFC4086">
<front>
<title>Randomness Requirements for Security</title>
<author initials="D." surname="Eastlake 3rd" fullname="D. Eastlake 3rd"><organization/></author>
<author initials="J." surname="Schiller" fullname="J. Schiller"><organization/></author>
<author initials="S." surname="Crocker" fullname="S. Crocker"><organization/></author>
<date year="2005" month="June"/>
<abstract><t>Security systems are built on strong cryptographic algorithms that foil pattern analysis attempts.  However, the security of these systems is dependent on generating secret quantities for passwords, cryptographic keys, and similar quantities.  The use of pseudo-random processes to generate secret quantities can result in pseudo-security. A sophisticated attacker may find it easier to reproduce the environment that produced the secret quantities and to search the resulting small set of possibilities than to locate the quantities in the whole of the potential number space.</t><t>Choosing random quantities to foil a resourceful and motivated adversary is surprisingly difficult.  This document points out many pitfalls in using poor entropy sources or traditional pseudo-random number generation techniques for generating such quantities.  It recommends the use of truly random hardware techniques and shows that the existing hardware on many systems can be used for this purpose. It provides suggestions to ameliorate the problem when a hardware solution is not available, and it gives examples of how large such quantities need to be for some applications.  This document specifies an Internet Best Current Practices for the Internet Community, and requests discussion and suggestions for improvements.</t></abstract>
</front>
<seriesInfo name="BCP" value="106"/>
<seriesInfo name="RFC" value="4086"/>
<seriesInfo name="DOI" value="10.17487/RFC4086"/>
</reference>



<reference anchor="RFC5198">
<front>
<title>Unicode Format for Network Interchange</title>
<author initials="J." surname="Klensin" fullname="J. Klensin"><organization/></author>
<author initials="M." surname="Padlipsky" fullname="M. Padlipsky"><organization/></author>
<date year="2008" month="March"/>
<abstract><t>The Internet today is in need of a standardized form for the transmission of internationalized "text" information, paralleling the specifications for the use of ASCII that date from the early days of the ARPANET.  This document specifies that format, using UTF-8 with normalization and specific line-ending sequences.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name="RFC" value="5198"/>
<seriesInfo name="DOI" value="10.17487/RFC5198"/>
</reference>



<reference anchor="RFC5234">
<front>
<title>Augmented BNF for Syntax Specifications: ABNF</title>
<author initials="D." surname="Crocker" fullname="D. Crocker" role="editor"><organization/></author>
<author initials="P." surname="Overell" fullname="P. Overell"><organization/></author>
<date year="2008" month="January"/>
<abstract><t>Internet technical specifications often need to define a formal syntax.  Over the years, a modified version of Backus-Naur Form (BNF), called Augmented BNF (ABNF), has been popular among many Internet specifications.  The current specification documents ABNF. It balances compactness and simplicity with reasonable representational power.  The differences between standard BNF and ABNF involve naming rules, repetition, alternatives, order-independence, and value ranges.  This specification also supplies additional rule definitions and encoding for a core lexical analyzer of the type common to several Internet specifications.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name="STD" value="68"/>
<seriesInfo name="RFC" value="5234"/>
<seriesInfo name="DOI" value="10.17487/RFC5234"/>
</reference>



<reference anchor="RFC5987">
<front>
<title>Character Set and Language Encoding for Hypertext Transfer Protocol (HTTP) Header Field Parameters</title>
<author initials="J." surname="Reschke" fullname="J. Reschke"><organization/></author>
<date year="2010" month="August"/>
<abstract><t>By default, message header field parameters in Hypertext Transfer Protocol (HTTP) messages cannot carry characters outside the ISO- 8859-1 character set.  RFC 2231 defines an encoding mechanism for use in Multipurpose Internet Mail Extensions (MIME) headers.  This document specifies an encoding suitable for use in HTTP header fields that is compatible with a profile of the encoding defined in RFC 2231.  [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name="RFC" value="5987"/>
<seriesInfo name="DOI" value="10.17487/RFC5987"/>
</reference>



<reference anchor="RFC6454">
<front>
<title>The Web Origin Concept</title>
<author initials="A." surname="Barth" fullname="A. Barth"><organization/></author>
<date year="2011" month="December"/>
<abstract><t>This document defines the concept of an "origin", which is often used as the scope of authority or privilege by user agents.  Typically, user agents isolate content retrieved from different origins to prevent malicious web site operators from interfering with the operation of benign web sites.  In addition to outlining the principles that underlie the concept of origin, this document details how to determine the origin of a URI and how to serialize an origin into a string.  It also defines an HTTP header field, named "Origin", that indicates which origins are associated with an HTTP request.   [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name="RFC" value="6454"/>
<seriesInfo name="DOI" value="10.17487/RFC6454"/>
</reference>



<reference anchor="RFC7230">
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</title>
<author initials="R." surname="Fielding" fullname="R. Fielding" role="editor"><organization/></author>
<author initials="J." surname="Reschke" fullname="J. Reschke" role="editor"><organization/></author>
<date year="2014" month="June"/>
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application-level protocol for distributed, collaborative, hypertext information systems.  This document provides an overview of HTTP architecture and its associated terminology, defines the "http" and "https" Uniform Resource Identifier (URI) schemes, defines the HTTP/1.1 message syntax and parsing requirements, and describes related security concerns for implementations.</t></abstract>
</front>
<seriesInfo name="RFC" value="7230"/>
<seriesInfo name="DOI" value="10.17487/RFC7230"/>
</reference>



<reference anchor="RFC7231">
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</title>
<author initials="R." surname="Fielding" fullname="R. Fielding" role="editor"><organization/></author>
<author initials="J." surname="Reschke" fullname="J. Reschke" role="editor"><organization/></author>
<date year="2014" month="June"/>
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines the semantics of HTTP/1.1 messages, as expressed by request methods, request header fields, response status codes, and response header fields, along with the payload of messages (metadata and body content) and mechanisms for content negotiation.</t></abstract>
</front>
<seriesInfo name="RFC" value="7231"/>
<seriesInfo name="DOI" value="10.17487/RFC7231"/>
</reference>



<reference anchor="RFC7234">
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Caching</title>
<author initials="R." surname="Fielding" fullname="R. Fielding" role="editor"><organization/></author>
<author initials="M." surname="Nottingham" fullname="M. Nottingham" role="editor"><organization/></author>
<author initials="J." surname="Reschke" fullname="J. Reschke" role="editor"><organization/></author>
<date year="2014" month="June"/>
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless \%application- level protocol for distributed, collaborative, hypertext information systems.  This document defines HTTP caches and the associated header fields that control cache behavior or indicate cacheable response messages.</t></abstract>
</front>
<seriesInfo name="RFC" value="7234"/>
<seriesInfo name="DOI" value="10.17487/RFC7234"/>
</reference>



<reference anchor="RFC7235">
<front>
<title>Hypertext Transfer Protocol (HTTP/1.1): Authentication</title>
<author initials="R." surname="Fielding" fullname="R. Fielding" role="editor"><organization/></author>
<author initials="J." surname="Reschke" fullname="J. Reschke" role="editor"><organization/></author>
<date year="2014" month="June"/>
<abstract><t>The Hypertext Transfer Protocol (HTTP) is a stateless application- level protocol for distributed, collaborative, hypermedia information systems.  This document defines the HTTP Authentication framework.</t></abstract>
</front>
<seriesInfo name="RFC" value="7235"/>
<seriesInfo name="DOI" value="10.17487/RFC7235"/>
</reference>


<!-- draft-ietf-precis-saslprepbis - RFC 7613 -->

<reference  anchor='RFC7613'>
<front>
<title>Preparation, Enforcement, and Comparison of Internationalized Strings Representing Usernames and Passwords</title>
<author initials='P.' surname='Saint-Andre' fullname='P. Saint-Andre'><organization /></author>
<author initials='A.' surname='Melnikov' fullname='A. Melnikov'><organization /></author>
<date year='2015' month='August' />
<abstract><t>This document describes updated methods for handling Unicode strings representing usernames and passwords.  The previous approach was known as SASLprep (RFC 4013) and was based on stringprep (RFC 3454). The methods specified in this document provide a more sustainable approach to the handling of internationalized usernames and passwords.  The preparation, enforcement, and comparison of internationalized strings (PRECIS) framework, RFC 7564, obsoletes RFC 3454, and this document obsoletes RFC 4013.</t></abstract>
</front>
<seriesInfo name='RFC' value='7613'/>
<seriesInfo name='DOI' value='10.17487/RFC7613'/>
</reference>


<!-- draft-ietf-httpbis-auth-info - RFC 7615 -->
  <reference anchor="RFC7615">
    <front>
      <title>HTTP Authentication-Info and Proxy-Authentication-Info Response Header Fields</title>
      <author initials="J." surname="Reschke" fullname="Julian Reschke"/>
      <date year="2015" month="September"/>
    </front>
    <seriesInfo name="RFC" value="7615"/>
    <seriesInfo name="DOI" value="10.17487/RFC7615"/>
  </reference>

</references>

<references title="Informative References">



<reference anchor="RFC2195">
<front>
<title>IMAP/POP AUTHorize Extension for Simple Challenge/Response</title>
<author initials="J." surname="Klensin" fullname="J. Klensin"><organization/></author>
<author initials="R." surname="Catoe" fullname="R. Catoe"><organization/></author>
<author initials="P." surname="Krumviede" fullname="P. Krumviede"><organization/></author>
<date year="1997" month="September"/>
<abstract><t>This specification provides a simple challenge-response authentication protocol that is suitable for use with IMAP4. [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name="RFC" value="2195"/>
<seriesInfo name="DOI" value="10.17487/RFC2195"/>
</reference>



<reference anchor="RFC2617">
<front>
<title>HTTP Authentication: Basic and Digest Access Authentication</title>
<author initials="J." surname="Franks" fullname="J. Franks"><organization/></author>
<author initials="P." surname="Hallam-Baker" fullname="P. Hallam-Baker"><organization/></author>
<author initials="J." surname="Hostetler" fullname="J. Hostetler"><organization/></author>
<author initials="S." surname="Lawrence" fullname="S. Lawrence"><organization/></author>
<author initials="P." surname="Leach" fullname="P. Leach"><organization/></author>
<author initials="A." surname="Luotonen" fullname="A. Luotonen"><organization/></author>
<author initials="L." surname="Stewart" fullname="L. Stewart"><organization/></author>
<date year="1999" month="June"/>
<abstract><t>This document provides the specification for HTTP's authentication framework, the original Basic authentication scheme and a scheme based on cryptographic hashes, referred to as "Digest Access Authentication". [STANDARDS-TRACK]</t></abstract>
</front>
<seriesInfo name="RFC" value="2617"/>
<seriesInfo name="DOI" value="10.17487/RFC2617"/>
</reference>



<reference anchor="RFC2818">
<front>
<title>HTTP Over TLS</title>
<author initials="E." surname="Rescorla" fullname="E. Rescorla"><organization/></author>
<date year="2000" month="May"/>
<abstract><t>This memo describes how to use Transport Layer Security (TLS) to secure Hypertext Transfer Protocol (HTTP) connections over the Internet.  This memo provides information for the Internet community.</t></abstract>
</front>
<seriesInfo name="RFC" value="2818"/>
<seriesInfo name="DOI" value="10.17487/RFC2818"/>
</reference>



<reference anchor="RFC4513">
<front>
<title>Lightweight Directory Access Protocol (LDAP): Authentication Methods and Security Mechanisms</title>
<author initials="R." surname="Harrison" fullname="R. Harrison" role="editor"><organization/></author>
<date year="2006" month="June"/>
</front>
<seriesInfo name="RFC" value="4513"/>
<seriesInfo name="DOI" value="10.17487/RFC4513"/>
</reference>



<reference anchor="RFC5226">
<front>
<title>Guidelines for Writing an IANA Considerations Section in RFCs</title>
<author initials="T." surname="Narten" fullname="T. Narten"><organization/></author>
<author initials="H." surname="Alvestrand" fullname="H. Alvestrand"><organization/></author>
<date year="2008" month="May"/>
<abstract><t>Many protocols make use of identifiers consisting of constants and other well-known values.  Even after a protocol has been defined and deployment has begun, new values may need to be assigned (e.g., for a new option type in DHCP, or a new encryption or authentication transform for IPsec).  To ensure that such quantities have consistent values and interpretations across all implementations, their assignment must be administered by a central authority.  For IETF protocols, that role is provided by the Internet Assigned Numbers Authority (IANA).</t><t>In order for IANA to manage a given namespace prudently, it needs guidelines describing the conditions under which new values can be assigned or when modifications to existing values can be made.  If IANA is expected to play a role in the management of a namespace, IANA must be given clear and concise instructions describing that role.  This document discusses issues that should be considered in formulating a policy for assigning values to a namespace and provides guidelines for authors on the specific text that must be included in documents that place demands on IANA.</t><t>This document obsoletes RFC 2434.  This document specifies an Internet Best  Current Practices for the Internet Community, and requests discussion and  suggestions for improvements.</t></abstract>
</front>
<seriesInfo name="BCP" value="26"/>
<seriesInfo name="RFC" value="5226"/>
<seriesInfo name="DOI" value="10.17487/RFC5226"/>
</reference>


<!-- draft-ietf-httpauth-basicauth-update - RFC 7617 -->
  <reference anchor="RFC7617">
    <front>
      <title>The 'Basic' HTTP Authentication Scheme</title>
      <author initials="J." surname="Reschke" fullname="Julian Reschke"/>
      <date month="September" year="2015"/>
    </front>
    <seriesInfo name="RFC" value="7617"/>
    <seriesInfo name="DOI" value="10.17487/RFC7617"/>
  </reference>

</references>

<section title="Changes from RFC 2617" anchor="rfc2617.changes">
<t>

This document introduces the following changes:
<list style="symbols">

<t>
Adds support for two new algorithms, SHA2-256 as mandatory and SHA2-512/256 as a backup, and defines the proper algorithm negotiation.
The document keeps the MD5 algorithm support but only for backward compatibility.
</t>

<t>
Introduces the username hashing capability and the parameter associated with that, mainly for privacy reasons.
</t>

<t>
Adds various internationalization considerations that impact the A1 calculation and username and password encoding.
</t>
<t>
  Introduces a new IANA registry, "Hash Algorithms for HTTP Digest Authentication",
  that lists the hash algorithms that can be used in HTTP Digest
  Authentication.
</t>
<t>
Deprecates backward compatibility with RFC 2069.
</t>

</list>
</t>

</section>

<section title="Acknowledgments" numbered="no">
<t>
To provide a complete description for the Digest mechanism and its operation, this document
borrows text heavily from <xref target="RFC2617"/>. The authors of this document would like to
thank John Franks, Phillip M.&nbsp;Hallam-Baker, Jeffery L.&nbsp;Hostetler, Scott D.&nbsp;Lawrence, Paul J.&nbsp;Leach,
Ari Luotonen, and Lawrence C.&nbsp;Stewart for their work on that specification.
</t>
<t>
Special thanks to Julian Reschke for his many reviews, comments, suggestions, and text provided to various areas in this document.
</t>
<t>
The authors would like to thank Stephen Farrell, Yoav Nir, Phillip Hallam-Baker, Manu Sporny, Paul Hoffman, Yaron Sheffer, Sean Turner,
Geoff Baskwill, Eric Cooper, Bjoern Hoehrmann, Martin Durst, Peter Saint-Andre, Michael Sweet,
Daniel Stenberg, Brett Tate, Paul Leach, Ilari Liusvaara, Gary Mort, Alexey Melnikov, Benjamin Kaduk,
Kathleen Moriarty, Francis Dupont, Hilarie Orman, and Ben Campbell for their careful review and comments.
</t>
<t>
The authors would like to thank Jonathan Stoke, Nico Williams, Harry Halpin, and Phil Hunt for their comments on the mailing list when discussing various aspects of this document.
</t>
<t>
The authors would like to thank Paul Kyzivat and Dale Worley for their careful review and feedback on some aspects of this document.
</t>
<t>
The authors would like to thank Barry Leiba for his help with the registry.
</t>

</section>


  </back>


</rfc>
